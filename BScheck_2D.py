# -*- coding: utf-8 -*-
"""
Created on Fri Nov  1 20:19:18 2024

@author: Jie Li
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.path import Path
import matplotlib as mpl


# When making modifications, 
# both the conformal transformation mapping function
# and its corresponding derivative need to be changed.

rho = 0.64 # the radius of former in z-plane, which is self-selected. 
N = int(1e4) 
# To calculate the mag field from current in the former by Bs law.
# Divide the number of current sheets on the former as finely as possible. 
theta_array = 2*np.pi*np.arange(N)/N


vertices = [] # store the coordinates in the current former
for i in range(N):
    z = rho * np.exp(1j * theta_array[i])
    zeta = -z**3 + z + 2/z  # the mapping we use
    vertices.append([zeta.real, zeta.imag])
vertices = np.array(vertices)

# check the shape of the corresponding former
plt.plot(vertices[:, 0], vertices[:, 1])
plt.axis("equal")
plt.show()


yArray, xArray= np.mgrid[-3.2:3.2:51j, -4.5:4.5:51j]
B_x_Array = np.zeros(np.shape(xArray))
B_y_Array = np.zeros(np.shape(xArray))

# calculate the field by BS law
for x_index in range(np.shape(xArray)[0]):
    print(x_index)
    for y_index in range(np.shape(xArray)[1]):
        x_temp = xArray[x_index, y_index]
        y_temp = yArray[x_index, y_index]
        point = (x_temp, y_temp)
        # is_inside = path.contains_point(point)

        if abs(x_temp) > 4.4 or abs(y_temp) > 3.2:
            B_x_Array[x_index, y_index] = np.nan
            B_y_Array[x_index, y_index] = np.nan
        else:
            for theta_index in range(len(theta_array)):
                theta = theta_array[theta_index]
                
                # The quadrupole generated by the quasi-rectangular former needs
                # a current density J~cos(2\theta)/|zeta'|
                
                # And the current sheet length is given by
                # ds = |zeta'| d\theta.
                
                # So the current sheet carries current  
                # I = J ds ~ cos(2\theta) d\theta
                # here d\theta is the same for all current sheets
                N_pole = 2
                # N_pole = 1 can generate dipole specially
                # N_pole = 0, no field inside
                cur = np.cos(N_pole * theta)
                
                z = rho * np.exp(1j * theta)
                zeta =-z**3 + z + 2/z # the mapping we use
                dis = np.hypot(x_temp - zeta.real, y_temp - zeta.imag)
                if dis < 1e-3:
                    continue
                # the BS law to check the results
                B_x_Array[x_index, y_index] += -(y_temp - zeta.imag) / dis ** 2 * cur
                B_y_Array[x_index, y_index] += +(x_temp - zeta.real) / dis ** 2 * cur



# plot the magnetic field
max_B = 0
B =  np.zeros(np.shape(xArray))
for x_index in range(np.shape(xArray)[0]):
    for y_index in range(np.shape(xArray)[1]):
        if np.isnan(B_x_Array[x_index, y_index]) == False:
            value = B_x_Array[x_index, y_index]**2 + B_y_Array[x_index, y_index]**2
            B[x_index, y_index] = value
            max_B = max(max_B, value)
B = B/max_B
norm = mpl.colors.Normalize(vmin=-0.40*np.max(B), vmax=np.max(B))
fig = plt.figure(figsize=(8, 6))
plt.streamplot(xArray, yArray, B_x_Array, B_y_Array, color=B, density=1.50, \
               norm =norm, arrowstyle="Fancy", cmap="Greys", linewidth=1.5)


# plot the current density in the former

x_list = []
y_list = []
colors = []

for i in range(N):
    z = rho * np.exp(1j * theta_array[i])
    zeta =  -z**3 + z + 2/z # the mapping
    zeta_prime =  - 3 * z**2 + 1 - 2/z**2 # the derivative of the mapping
    x_list.append(zeta.real)
    y_list.append(zeta.imag)
    # plot the current density in the former
    colors.append((np.cos(N_pole * theta_array[i]))/np.abs(zeta_prime))
plt.scatter(x_list, y_list, c=colors, cmap='seismic')

plt.axis("equal")
plt.axis("off")
plt.show()


